<!doctype html><html lang=en><head><meta charset=utf-8><title>Tidbits</title><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content="title: Permutations in Rust Code description: date: 2023-12-28 draft: false categories:
 Personal Journal Development tags: Personal Journal Mathematics   This is a bit of a continuation of the last post here
I have implemented a very simple permutation group bit of code. The idea behind the design of this showcases why I think algebraic type systems are so powerful. Simply put, only operations between permutations that act on the same number of objects make any sense."><meta name=author content="Jack Champagne"><meta name=generator content="Hugo 0.71.1"><link href=/index.xml rel=alternate type=application/rss+xml title="Tidbits Feed"><link rel=stylesheet href=/style.7c6d960b20273ed88bc63a60591a57e7739fb21f243b77f27c3bc730ef6205c0.css><script defer src=/script.9df38729991a6ec08d83b60514e841529cebd5ccc800cf8e1f98fb63e73aaa73.js></script></head><body><div class=pure-g><div class="pure-u-1-24 pure-u-md-5-24"></div><div class="pure-u-22-24 pure-u-md-14-24"><div class=navigation><div class="navigation-header clearfix"><div class="pure-menu pure-menu-horizontal"><a class="pure-menu-heading pure-menu-link" href=/>Tidbits</a><ul class="pure-menu-list navigation-header-subtitle pull-end"><li class="pure-menu-item pure-menu-disabled">A Journal</li></ul></div></div><div class=navigation-content><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class=pure-menu-item title="All posts"><a class=pure-menu-link href=/posts/>Posts</a></li><li class=pure-menu-item title="All categories"><a class=pure-menu-link href=/categories/>Categories</a></li><li class=pure-menu-item title="All series"><a class=pure-menu-link href=/series/>Series</a></li><li class=pure-menu-item title="All tags"><a class=pure-menu-link href=/tags/>Tags</a></li></ul></div></div></div><div><div><h2 class=post-title></h2><div class=post-meta><span>Date</span> [
<time datetime=0001-01-01T00:00:00Z>Mon, 01 Jan 0001 00:00:00 UTC</time>
]</div></div><div><p>title: Permutations in Rust Code
description:
date: 2023-12-28
draft: false
categories:</p><ul><li>Personal</li><li>Journal</li><li>Development
tags:</li><li>Personal</li><li>Journal</li><li>Mathematics</li></ul><hr><p>This is a bit of a continuation of the last post <a href=/2023-12-26-minimal-representations.md>here</a></p><p>I have implemented a very simple permutation group bit of code. The idea behind the design of this showcases why I think algebraic type systems are so powerful. Simply put, only operations between permutations that act on the same number of objects make any sense. This of course is usually not a problem when the permutations are of different lengths, its always easy to insert an identity map to additional elements on the smaller of the two then proceed, but leveraging rusts type system to ensure that operations accept operands of the same group is a powerful thing.</p><p>I decided that the representation of a permutation should be an array. Each index of the array contains what that element maps to. If I wanted to represent a permutation in which 2 items swap, in cycle notation it would be written like so: (1 2).</p><p>Looking at the internal array for this permutation, it looks a bit strange: [2, 1]. There is a bit of a tension here between standard mathematical notation and computer programming, although unimportant. In standard permutation notation, 1 is the first element. Thus this array is saying that 1 maps to 2, and 2 maps to 1. Of course in code, the indexcies are off by one. Why does an internal implementation conform to such arbitrary standards? Mainly cause of my comfort with existing notation.</p><p>Here are some key snippets from the code</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Debug, Clone)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>Permutation</span><span class=o>&lt;</span><span class=k>const</span><span class=w> </span><span class=n>SIZE</span>: <span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>map</span>: <span class=p>[</span><span class=kt>usize</span><span class=p>;</span><span class=w> </span><span class=n>SIZE</span><span class=p>],</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>and this one</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=o>&lt;</span><span class=k>const</span><span class=w> </span><span class=n>SIZE</span>: <span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=n>Permutation</span><span class=o>&lt;</span><span class=n>SIZE</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>compose</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=kp>&amp;</span><span class=nc>Permutation</span><span class=o>&lt;</span><span class=n>SIZE</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>map_copy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>map</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=n>SIZE</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>map_copy</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>other</span><span class=p>.</span><span class=n>map</span><span class=p>[</span><span class=n>Self</span>::<span class=n>index_from_elem</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>map</span><span class=p>[</span><span class=n>index</span><span class=p>])];</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>map</span>: <span class=nc>map_copy</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>pretty great! This allows chaining compositions like so:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>s4_1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Permutation</span>::<span class=o>&lt;</span><span class=mi>4</span><span class=o>&gt;</span>::<span class=n>random</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>s4_2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Permutation</span>::<span class=o>&lt;</span><span class=mi>4</span><span class=o>&gt;</span>::<span class=n>random</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=c1>// e • (s4_2 • (s4_2 • s4_1)) = ??
</span><span class=c1></span><span class=n>dbg</span><span class=o>!</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s4_1</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>compose</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s4_2</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>compose</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s4_2</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>.</span><span class=n>compose</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Permutation</span>::<span class=o>&lt;</span><span class=mi>4</span><span class=o>&gt;</span>::<span class=n>new</span><span class=p>()));</span><span class=w>
</span></code></pre></div><p>Thus if s4_1 = (1)(2 4 3), s4_2 = (1 3 4)(2), and e = (1)(2)(3)(4) per usual&mldr;</p><p><code>e • (s4\_2 • (s4\_2 • s4\_1)) = (1)(2)(3)(4) • (1 3 4)(2) • (1 3 4)(2) • (1)(2 4 3) = (1 4)(2 3)</code></p><p>or as output:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash><span class=o>[</span>src/main.rs:103<span class=o>]</span> <span class=p>&amp;</span>s4_1.compose<span class=o>(</span><span class=p>&amp;</span>s4_2<span class=o>)</span>.compose<span class=o>(</span><span class=p>&amp;</span>s4_2<span class=o>)</span>.compose<span class=o>(</span><span class=p>&amp;</span>Permutation::&lt;4&gt;::new<span class=o>())</span> <span class=o>=</span> Permutation <span class=o>{</span>
    map: <span class=o>[</span>
        4,
        3,
        2,
        1,
    <span class=o>]</span>,
<span class=o>}</span>
</code></pre></div><p>Excellent!</p><p>Next, implementing the cyclic groups</p></div></div><div class=footer><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class=pure-menu-item title="Theme repository"><a class=pure-menu-link href=https://github.com/jack-champagne/jack-champagne.github.io>GitHub</a></li><li class=pure-menu-item title="Theme page on gohugo.io"><a class=pure-menu-link href=https://themes.gohugo.io/slick>Slick</a></li><li class=pure-menu-item title=Top><a class=pure-menu-link href=#>To Top</a></li><li class=pure-menu-item title="RSS Feed"><a href=/index.xml class=pure-menu-link>RSS</a></li><li class="pure-menu-item fix-cursor-pointer" title="Go to top"><a class=pure-menu-link id=btn-gototop><span class=fix-placement-up>&#8679;&#xfe0e;</span></a></li></ul></div><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class="pure-menu-item pure-menu-disabled">&copy; 2023 &mdash; Jack Champagne — All rights reserved.</li></ul></div></div></div><div class="pure-u-1-24 pure-u-md-5-24"></div></div></body></html>