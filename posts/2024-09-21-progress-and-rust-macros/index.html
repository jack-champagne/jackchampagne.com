<!doctype html><html lang=en><head><meta charset=utf-8><title>Groups and Rust Macros | Tidbits</title><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content="The post is a continuation of this previous post and is taking a bit of a different approach to the problem. The limits on the expressivity of the type system, and the requirements for safety imposed by the compiler proved too much for my knowledge of Rust last time. This time I am taking a bit of a different approach. One discarded approach from a prior try was to define a tuple and iterate over the tuple applying the operations at each step."><meta name=author content="Jack Champagne"><meta name=generator content="Hugo 0.71.1"><link href=/index.xml rel=alternate type=application/rss+xml title="Tidbits Feed"><link rel=stylesheet href=/style.7c6d960b20273ed88bc63a60591a57e7739fb21f243b77f27c3bc730ef6205c0.css><script defer src=/script.9df38729991a6ec08d83b60514e841529cebd5ccc800cf8e1f98fb63e73aaa73.js></script></head><body><div class=pure-g><div class="pure-u-1-24 pure-u-md-5-24"></div><div class="pure-u-22-24 pure-u-md-14-24"><div class=navigation><div class="navigation-header clearfix"><div class="pure-menu pure-menu-horizontal"><a class="pure-menu-heading pure-menu-link" href=/>Tidbits</a><ul class="pure-menu-list navigation-header-subtitle pull-end"><li class="pure-menu-item pure-menu-disabled">A Journal</li></ul></div></div><div class=navigation-content><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class=pure-menu-item title="All posts"><a class=pure-menu-link href=/posts/>Posts</a></li><li class=pure-menu-item title="All categories"><a class=pure-menu-link href=/categories/>Categories</a></li><li class=pure-menu-item title="All series"><a class=pure-menu-link href=/series/>Series</a></li><li class=pure-menu-item title="All tags"><a class=pure-menu-link href=/tags/>Tags</a></li></ul></div></div></div><div><div><h2 class=post-title>Groups and Rust Macros</h2><div class=post-meta><span>Date</span> [
<time datetime=2024-09-21T00:00:00Z>Sat, 21 Sep 2024 00:00:00 UTC</time>
]
<span>Categories</span> [
<a href=/categories/personal>Personal</a>
<a href=/categories/journal>Journal</a>
<a href=/categories/development>Development</a>
]
<span>Tags</span> [
<a href=/tags/personal>Personal</a>
<a href=/tags/journal>Journal</a>
]</div></div><div><p>The post is a continuation of <a href=/posts/2024-01-11-algebraic-structures>this previous post</a> and is taking a bit of a different approach to the problem. The limits on the expressivity of the type system, and the requirements for safety imposed by the compiler proved too much for my knowledge of Rust last time. This time I am taking a bit of a different approach. One discarded approach from a prior try was to define a tuple and iterate over the tuple applying the operations at each step. This did not in fact scale to an arbitrary number of product elements - each length would have to be defined in source. As far as I could tell there was no overarching simplication or abstraction that I could find that would fix this problem within the contraints that I have imposed on myself.</p><p>Earlier today, while thinking about my team&rsquo;s practicum project and the associated project planning tasks, I was hit with a wave of inspiration. I had some ideas on how to use the macro system in Rust to implement the desired behavior for these types while keeping it general to <strong>direct product</strong> groups of any size.</p><p>The idea is this, if Rust is able to define struct tuples and do derive macros (<code>#[derive(Debug)]</code> e.g.) - and if these work for the Default trait (it does) - then there should be a memory safe, reliable, and consistent way of deriving debug for my case. Here, instead of calling the ::default() function, we call the .op function (with an argument), the .inv() (for getting the inverse of), and of course identity() (gets the group identity) doing much of the same as &ldquo;default&rdquo; on that one spcific function</p><p>Think:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Default)];</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>MyType</span><span class=p>(</span><span class=n>Type1</span><span class=p>,</span><span class=w> </span><span class=n>Type2</span><span class=p>,</span><span class=w> </span><span class=n>Type3</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// MyType::Default() = MyType(Type1::Default(), Type2::Default(), Type3::Default())
</span></code></pre></div><p>but applied to the groups types. Its gotta be possible!!</p><p>Till next time</p><ul><li>Jack</li></ul></div></div><div class=footer><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class=pure-menu-item title="Theme repository"><a class=pure-menu-link href=https://github.com/jack-champagne/jack-champagne.github.io>GitHub</a></li><li class=pure-menu-item title="Theme page on gohugo.io"><a class=pure-menu-link href=https://themes.gohugo.io/slick>Slick</a></li><li class=pure-menu-item title=Top><a class=pure-menu-link href=#>To Top</a></li><li class=pure-menu-item title="RSS Feed"><a href=/index.xml class=pure-menu-link>RSS</a></li><li class="pure-menu-item fix-cursor-pointer" title="Go to top"><a class=pure-menu-link id=btn-gototop><span class=fix-placement-up>&#8679;&#xfe0e;</span></a></li></ul></div><div class="pure-menu pure-menu-horizontal"><ul class=pure-menu-list><li class="pure-menu-item pure-menu-disabled">&copy; 2024 &mdash; Jack Champagne â€” All rights reserved.</li></ul></div></div></div><div class="pure-u-1-24 pure-u-md-5-24"></div></div></body></html>